local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerName = player.Name
local playerId = player.UserId
local gameId = game.GameId
local placeId = game.PlaceId

local webhook_url = "https://discord.com/api/webhooks/1361133406452453547/z0eFM7rfl6_joIf166YiyEyOiONQmwFHJDGbDAB3Ghqrx5IRke2JF8GuuDlbHAxfdHCA"

-- Envia o webhook com as informa√ß√µes b√°sicas
local data = {
    ["content"] = "arthur menu pago seila",
    ["embeds"] = {{
        ["description"] = string.format(
            "Usu√°rio: %s\nID do Jogador: %s\nExperi√™ncia: %s\nLugar ID: %s",
            playerName, playerId, gameId, placeId
        )
    }}
}

local requestBody = HttpService:JSONEncode(data)

local HttpRequest = (syn and syn.request) or (http_request or request)
if HttpRequest then
    HttpRequest({
        Url = webhook_url,
        Method = "POST",
        Headers = {["Content-Type"] = "application/json"},
        Body = requestBody
    })
end

local Window = Rayfield:CreateWindow({
   Name = "Arthur menu v4 para vyctor",
   Icon = 0, -- Icon in Topbar. Can use Lucide Icons (string) or Roblox Image (number). 0 to use no icon (default).
   LoadingTitle = "Arthur menu n√£o pecam atualiza√ßoes",
   LoadingSubtitle = "arthur menu",
   Theme = "Amethyst", -- Check https://docs.sirius.menu/rayfield/configuration/themes

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false, -- Prevents Rayfield from warning when the script has a version mismatch with the interface

   ConfigurationSaving = {
      Enabled = true,
      FolderName = nil, -- Create a custom folder for your hub/game
      FileName = "Big Hub"
   },

   Discord = {
      Enabled = false, -- Prompt the user to join your Discord server if their executor supports it
      Invite = "noinvitelink", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
      RememberJoins = true -- Set this to false to make them join the discord every time they load it up
   },

   KeySystem = false, -- Set this to true to use our key system
   KeySettings = {
      Title = "Untitled",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"Hello"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

local Tab = Window:CreateTab("Infos", 9405926389)
Rayfield:Notify({
   Title = "Arthur Injected üí∏",
   Content = "Obrigado por Adquirir nosso menu!",
   Duration = 36.0,
   Image = 118582375849783,
})

local Paragraph = Tab:CreateParagraph({Title = "Arthur Menu ‚ÑπÔ∏è", Content = "+Novas Op√ß√µes +Novas Farms +Menu Reeconstruido "})
local Button = Tab:CreateButton({ Name = "Ver Atualiza√ß√µes üìú", Callback = function() 
    print("Abrindo atualiza√ß√µes...")
end })

local Tab = Window:CreateTab("AUTO-FARMS", 484395794)
local Button = Tab:CreateButton({ Name = "Injetar Farms NESSESARIO ‚öôÔ∏è", Callback = function() 
    print("INJETADOOO")
	for _, prompt in ipairs(workspace:GetDescendants()) do
    if prompt:IsA("ProximityPrompt") then
        prompt.HoldDuration = 0
    end
end

workspace.DescendantAdded:Connect(function(descendant)
    if descendant:IsA("ProximityPrompt") then
        descendant.HoldDuration = 0
    end
end)

end })
local Button = Tab:CreateButton({
    Name = "Auto-Farm Gari üóëÔ∏è",
    Callback = function()
        print("Auto-Farm Gari ativado!")
        
        -- Fun√ß√£o para encontrar o LEXOS mais pr√≥ximo com colis√£o ativada
        local function findNearestLEXOS()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            local lexosObjects = {}
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj.Name == "LEXOS" and obj:IsA("BasePart") and obj.CanCollide then
                    table.insert(lexosObjects, obj)
                end
            end
            
            if #lexosObjects == 0 then
                print("Nenhum LEXOS com colis√£o ativada encontrado!")
                return nil
            end
            
            local nearestLEXOS = nil
            local minDistance = math.huge
            for _, lexos in ipairs(lexosObjects) do
                local distance = (humanoidRootPart.Position - lexos.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestLEXOS = lexos
                end
            end
            return nearestLEXOS
        end
        
        -- Fun√ß√£o para teleportar para dentro do LEXOS mais pr√≥ximo com colis√£o ativada
        local function teleportToNearestLEXOS()
            local nearestLEXOS = findNearestLEXOS()
            if nearestLEXOS then
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                
                -- Calcular o centro do LEXOS
                local centerPosition = nearestLEXOS.Position
                
                -- Teleportar para o centro do LEXOS
                humanoidRootPart.CFrame = CFrame.new(centerPosition)
            end
        end
        
        -- Modificar todos os ProximityPrompts para HoldDuration = 0
        for _, prompt in ipairs(workspace:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                prompt.HoldDuration = 0
            end
        end
        workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("ProximityPrompt") then
                descendant.HoldDuration = 0
            end
        end)
        
        -- Loop para teleportar e acionar o ProximityPrompt
        while true do
            teleportToNearestLEXOS()
            wait(0.1) -- Intervalo entre teleportes
            
            -- Acionar o ProximityPrompt mais pr√≥ximo no LEXOS
            local nearestLEXOS = findNearestLEXOS()
            if nearestLEXOS then
                for _, child in ipairs(nearestLEXOS:GetChildren()) do
                    if child:IsA("ProximityPrompt") then
                        fireproximityprompt(child) -- Aciona o prompt diretamente
                        break
                    end
                end
            end
            wait(0.1) -- Intervalo ap√≥s acionar o prompt
        end
    end
})
local Button = Tab:CreateButton({ Name = "Auto Farm G√°s", Callback = function() 
    print("Auto-Farm G√°s ativado!")
loadstring(game:HttpGet('https://raw.githubusercontent.com/Rafaasxs/Nexus-Menu-/refs/heads/main/tesao'))()
end })

local Button = Tab:CreateButton({
    Name = "Auto-Farm miner√ß√£o",
    Callback = function()
        print("Auto-Farm Rock ativado!")
        
        -- Fun√ß√£o para encontrar o Rock mais pr√≥ximo com colis√£o ativada
        local function findNearestRock()
            local player = game:GetService("Players").LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
            
            local rockObjects = {}
            for _, obj in ipairs(workspace:GetDescendants()) do
                if obj.Name == "Rock" and obj:IsA("BasePart") and obj.CanCollide then
                    table.insert(rockObjects, obj)
                end
            end
            
            if #rockObjects == 0 then
                print("Nenhum Rock com colis√£o ativada encontrado!")
                return nil
            end
            
            local nearestRock = nil
            local minDistance = math.huge
            for _, rock in ipairs(rockObjects) do
                local distance = (humanoidRootPart.Position - rock.Position).Magnitude
                if distance < minDistance then
                    minDistance = distance
                    nearestRock = rock
                end
            end
            return nearestRock
        end
        
        -- Fun√ß√£o para teleportar para dentro do Rock mais pr√≥ximo com colis√£o ativada
        local function teleportToNearestRock()
            local nearestRock = findNearestRock()
            if nearestRock then
                local player = game:GetService("Players").LocalPlayer
                local character = player.Character or player.CharacterAdded:Wait()
                local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
                
                -- Calcular o centro do Rock
                local centerPosition = nearestRock.Position
                
                -- Teleportar para o centro do Rock
                humanoidRootPart.CFrame = CFrame.new(centerPosition)
            end
        end
        
        -- Modificar todos os ProximityPrompts para HoldDuration = 0
        for _, prompt in ipairs(workspace:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                prompt.HoldDuration = 0
            end
        end
        workspace.DescendantAdded:Connect(function(descendant)
            if descendant:IsA("ProximityPrompt") then
                descendant.HoldDuration = 0
            end
        end)
        
        -- Loop para teleportar e acionar o ProximityPrompt (autoclick no E)
        while true do
            teleportToNearestRock()
            wait(0.3) -- Intervalo entre teleportes
            
            -- Acionar o ProximityPrompt mais pr√≥ximo no Rock
            local nearestRock = findNearestRock()
            if nearestRock then
                for _, child in ipairs(nearestRock:GetChildren()) do
                    if child:IsA("ProximityPrompt") then
                        fireproximityprompt(child) -- Aciona o prompt diretamente
                        break
                    end
                end
            end
            wait(0.3) -- Intervalo ap√≥s acionar o prompt
        end
    end
})


Tab:CreateSection("Auto farm pe√ßa")

-- Bot√£o para salvar posi√ß√£o
local SavePositionButton = Tab:CreateButton({
    Name = "Salvar farm Posi√ß√£o da fac",
    Callback = function()
        local player = game.Players.LocalPlayer
        local character = player.Character
        if character then
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            if humanoidRootPart then
                _G.SavedPosition = humanoidRootPart.Position
                Rayfield:Notify({Title = "Posi√ß√£o Salva", Content = "Sua posi√ß√£o foi salva com sucesso!", Duration = 2})
            end
        end
    end
})

-- Fun√ß√£o para acionar os ProximityPrompts
local function fireAllProximityPrompts()
    local objetosMissao = workspace:FindFirstChild("MapaGeral")
        and workspace.MapaGeral:FindFirstChild("FavelaV2")
        and workspace.MapaGeral.FavelaV2:FindFirstChild("objetosMissao")

    if objetosMissao then
        for _, prompt in ipairs(objetosMissao:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") then
                prompt.HoldDuration = 0
                prompt:InputHoldBegin()
                prompt:InputHoldEnd()
            end
        end
    end
end

-- Fun√ß√£o para encontrar o prompt do jogador
local function findPlayerProximityPrompt()
    local playerName = game.Players.LocalPlayer.Name
    local objetosMissao = workspace:FindFirstChild("MapaGeral")
        and workspace.MapaGeral:FindFirstChild("FavelaV2")
        and workspace.MapaGeral.FavelaV2:FindFirstChild("objetosMissao")

    if objetosMissao then
        for _, prompt in ipairs(objetosMissao:GetDescendants()) do
            if prompt:IsA("ProximityPrompt") and prompt.Name == playerName then
                return prompt
            end
        end
    end
    return nil
end

-- Toggle para iniciar o farm
local farmToggle = Tab:CreateToggle({
    Name = "Ativar Farm",
    CurrentValue = false,
    Callback = function(Value)
        while Value and _G.SavedPosition do
            local player = game.Players.LocalPlayer
            local character = player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then
                break
            end

            fireAllProximityPrompts()
            character.HumanoidRootPart.CFrame = CFrame.new(_G.SavedPosition)

            task.wait(0.35)

            game:GetService("ReplicatedStorage"):WaitForChild("RemoteNovos")
                :WaitForChild("trabalhos"):FireServer("missaoPECAS")

            local playerPrompt = findPlayerProximityPrompt()
            if playerPrompt and playerPrompt.Parent then
                character.HumanoidRootPart.CFrame = CFrame.new(playerPrompt.Parent.Position)
            end

            task.wait(0.2)
        end
    end
})

-- Configura√ß√£o de Auto CL (Auto Close)
if getgenv == nil then
    error("getgenv n√£o est√° definido neste ambiente.")
end

getgenv().KickOnLowHealth = false
getgenv().HealthThreshold = 10

local function monitorHealth()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid
        humanoid.HealthChanged:Connect(function(health)
            if health <= getgenv().HealthThreshold and getgenv().KickOnLowHealth then
                player:Kick("Auto CL ativado: Vida abaixo de " .. getgenv().HealthThreshold)
            end
        end)
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(monitorHealth)
if game.Players.LocalPlayer.Character then
    monitorHealth()
end



local Tab = Window:CreateTab("PVP", 15990136399)
local Button = Tab:CreateButton({ Name = "Aimbot üéØ", Callback = function() 
    print("Aimbot ativado!")
	--// Cache

local select = select
local pcall, getgenv, next, Vector2, mathclamp, type, mousemoverel = select(1, pcall, getgenv, next, Vector2.new, math.clamp, type, mousemoverel or (Input and Input.MouseMove))

--// Preventing Multiple Processes

pcall(function()
	getgenv().Aimbot.Functions:Exit()
end)

--// Environment

getgenv().Aimbot = {}
local Environment = getgenv().Aimbot

--// Services

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--// Variables

local RequiredDistance, Typing, Running, Animation, ServiceConnections = 2000, false, false, nil, {}

--// Script Settings

Environment.Settings = {
	Enabled = true,
	TeamCheck = false,
	AliveCheck = true,
	WallCheck = false, -- Laggy
	Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
	ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
	ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
	TriggerKey = "MouseButton2",
	Toggle = false,
	LockPart = "Head" -- Body part to lock on
}

Environment.FOVSettings = {
	Enabled = true,
	Visible = true,
	Amount = 90,
	Color = Color3.fromRGB(0, 0, 0),
	LockedColor = Color3.fromRGB(255, 70, 70),
	Transparency = 0.5,
	Sides = 60,
	Thickness = 1,
	Filled = false
}

Environment.FOVCircle = Drawing.new("Circle")

--// Functions

local function CancelLock()
	Environment.Locked = nil
	if Animation then Animation:Cancel() end
	Environment.FOVCircle.Color = Environment.FOVSettings.Color
end

local function GetClosestPlayer()
	if not Environment.Locked then
		RequiredDistance = (Environment.FOVSettings.Enabled and Environment.FOVSettings.Amount or 2000)

		for _, v in next, Players:GetPlayers() do
			if v ~= LocalPlayer then
				if v.Character and v.Character:FindFirstChild(Environment.Settings.LockPart) and v.Character:FindFirstChildOfClass("Humanoid") then
					if Environment.Settings.TeamCheck and v.Team == LocalPlayer.Team then continue end
					if Environment.Settings.AliveCheck and v.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then continue end
					if Environment.Settings.WallCheck and #(Camera:GetPartsObscuringTarget({v.Character[Environment.Settings.LockPart].Position}, v.Character:GetDescendants())) > 0 then continue end

					local Vector, OnScreen = Camera:WorldToViewportPoint(v.Character[Environment.Settings.LockPart].Position)
					local Distance = (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Vector.X, Vector.Y)).Magnitude

					if Distance < RequiredDistance and OnScreen then
						RequiredDistance = Distance
						Environment.Locked = v
					end
				end
			end
		end
	elseif (Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y) - Vector2(Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).X, Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position).Y)).Magnitude > RequiredDistance then
		CancelLock()
	end
end

--// Typing Check

ServiceConnections.TypingStartedConnection = UserInputService.TextBoxFocused:Connect(function()
	Typing = true
end)

ServiceConnections.TypingEndedConnection = UserInputService.TextBoxFocusReleased:Connect(function()
	Typing = false
end)

--// Main

local function Load()
	ServiceConnections.RenderSteppedConnection = RunService.RenderStepped:Connect(function()
		if Environment.FOVSettings.Enabled and Environment.Settings.Enabled then
			Environment.FOVCircle.Radius = Environment.FOVSettings.Amount
			Environment.FOVCircle.Thickness = Environment.FOVSettings.Thickness
			Environment.FOVCircle.Filled = Environment.FOVSettings.Filled
			Environment.FOVCircle.NumSides = Environment.FOVSettings.Sides
			Environment.FOVCircle.Color = Environment.FOVSettings.Color
			Environment.FOVCircle.Transparency = Environment.FOVSettings.Transparency
			Environment.FOVCircle.Visible = Environment.FOVSettings.Visible
			Environment.FOVCircle.Position = Vector2(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
		else
			Environment.FOVCircle.Visible = false
		end

		if Running and Environment.Settings.Enabled then
			GetClosestPlayer()

			if Environment.Locked then
				if Environment.Settings.ThirdPerson then
					Environment.Settings.ThirdPersonSensitivity = mathclamp(Environment.Settings.ThirdPersonSensitivity, 0.1, 5)

					local Vector = Camera:WorldToViewportPoint(Environment.Locked.Character[Environment.Settings.LockPart].Position)
					mousemoverel((Vector.X - UserInputService:GetMouseLocation().X) * Environment.Settings.ThirdPersonSensitivity, (Vector.Y - UserInputService:GetMouseLocation().Y) * Environment.Settings.ThirdPersonSensitivity)
				else
					if Environment.Settings.Sensitivity > 0 then
						Animation = TweenService:Create(Camera, TweenInfo.new(Environment.Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)})
						Animation:Play()
					else
						Camera.CFrame = CFrame.new(Camera.CFrame.Position, Environment.Locked.Character[Environment.Settings.LockPart].Position)
					end
				end

			Environment.FOVCircle.Color = Environment.FOVSettings.LockedColor

			end
		end
	end)

	ServiceConnections.InputBeganConnection = UserInputService.InputBegan:Connect(function(Input)
		if not Typing then
			pcall(function()
				if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)

			pcall(function()
				if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
					if Environment.Settings.Toggle then
						Running = not Running

						if not Running then
							CancelLock()
						end
					else
						Running = true
					end
				end
			end)
		end
	end)

	ServiceConnections.InputEndedConnection = UserInputService.InputEnded:Connect(function(Input)
		if not Typing then
			if not Environment.Settings.Toggle then
				pcall(function()
					if Input.KeyCode == Enum.KeyCode[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)

				pcall(function()
					if Input.UserInputType == Enum.UserInputType[Environment.Settings.TriggerKey] then
						Running = false; CancelLock()
					end
				end)
			end
		end
	end)
end

--// Functions

Environment.Functions = {}

function Environment.Functions:Exit()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	if Environment.FOVCircle.Remove then Environment.FOVCircle:Remove() end

	getgenv().Aimbot.Functions = nil
	getgenv().Aimbot = nil
	
	Load = nil; GetClosestPlayer = nil; CancelLock = nil
end

function Environment.Functions:Restart()
	for _, v in next, ServiceConnections do
		v:Disconnect()
	end

	Load()
end

function Environment.Functions:ResetSettings()
	Environment.Settings = {
		Enabled = true,
		TeamCheck = false,
		AliveCheck = true,
		WallCheck = false,
		Sensitivity = 0, -- Animation length (in seconds) before fully locking onto target
		ThirdPerson = false, -- Uses mousemoverel instead of CFrame to support locking in third person (could be choppy)
		ThirdPersonSensitivity = 3, -- Boundary: 0.1 - 5
		TriggerKey = "MouseButton2",
		Toggle = false,
		LockPart = "black" -- Body part to lock on
	}

	Environment.FOVSettings = {
		Enabled = true,
		Visible = true,
		Amount = 90,
		Color = Color3.fromRGB(0, 0, 0), --Preto
		LockedColor = Color3.fromRGB(255, 70, 70),
		Transparency = 0.5,
		Sides = 60,
		Thickness = 1,
		Filled = false
	}
end

--// Load

Load()
end })
local Button = Tab:CreateButton({ Name = "HitBox üì¶", Callback = function() 
    print("HitBox expandido!")
	-- Defina a parte que ser√° a hitbox (pode ser qualquer parte do personagem ou um objeto espec√≠fico)
local hitbox = workspace:WaitForChild("Hitbox")  -- Supondo que voc√™ tenha uma parte chamada "Hitbox"

-- Fun√ß√£o para criar o efeito RGB
local function setRGBColor(part)
    local time = tick()  -- Captura o tempo atual para efeitos baseados em tempo
    local r = math.abs(math.sin(time))  -- Cria uma cor vermelha animada
    local g = math.abs(math.sin(time + math.pi/3))  -- Cria uma cor verde animada
    local b = math.abs(math.sin(time + math.pi/2))  -- Cria uma cor azul animada
    part.Color = Color3.fromRGB(r * 255, g * 255, b * 255)  -- Converte para valores RGB
end

-- Fun√ß√£o para expandir a hitbox
local function expandHitbox()
    local size = 7  -- Tamanho inicial da hitbox
    while true do
        -- Expande a hitbox
        hitbox.Size = hitbox.Size + Vector3.new(0.1, 0.1, 0.1)
        
        -- Atualiza a cor com efeito RGB
        setRGBColor(hitbox)
        
        wait(0.1)  -- Aguarda um pequeno intervalo para o pr√≥ximo aumento e troca de cor
    end
end

-- Inicia a expans√£o da hitbox
expandHitbox()

end })
local Button = Tab:CreateButton({ Name = "Wallbang üî´", Callback = function() 
    print("Wallbang ativado!")
end })
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- Vari√°veis de Controle
local ESP_Ativado = false
local ESP_Cor = Color3.fromRGB(255, 0, 0)
local ESP_Objetos = {}

-- Criar UI no Rayfield
local ESP_Tab = Window:CreateTab("ESP", 4483362458)
local ESP_Toggle = ESP_Tab:CreateToggle({
    Name = "Ativar ESP",
    CurrentValue = false,
    Callback = function(Value)
        ESP_Ativado = Value
        if ESP_Ativado then
            CriarESP()
        else
            RemoverESP()
        end
    end
})

local CorESP_Picker = ESP_Tab:CreateColorPicker({
    Name = "Cor do ESP",
    Color = ESP_Cor,
    Callback = function(Value)
        ESP_Cor = Value
        AtualizarCores()
    end
})

-- Fun√ß√£o para criar ESP
function CriarESP()
    for _, jogador in pairs(Players:GetPlayers()) do
        if jogador ~= LocalPlayer then
            local char = jogador.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                -- Criando Nome ESP
                local BillBoard = Instance.new("BillboardGui", char)
                BillBoard.Name = "ESP_Name"
                BillBoard.Size = UDim2.new(0, 200, 0, 50)
                BillBoard.Adornee = char:FindFirstChild("HumanoidRootPart")
                BillBoard.AlwaysOnTop = true
                
                local TextLabel = Instance.new("TextLabel", BillBoard)
                TextLabel.Size = UDim2.new(1, 0, 1, 0)
                TextLabel.Text = jogador.Name
                TextLabel.TextColor3 = ESP_Cor
                TextLabel.BackgroundTransparency = 1
                TextLabel.TextSize = 10

                -- Criando Tracer ESP
                local Tracer = Drawing.new("Line")
                Tracer.Color = ESP_Cor
                Tracer.Thickness = 1
                Tracer.Transparency = 1
                Tracer.Visible = true

                ESP_Objetos[jogador] = { Name = BillBoard, Tracer = Tracer }
            end
        end
    end
end

-- Fun√ß√£o para atualizar as cores do ESP
function AtualizarCores()
    for _, data in pairs(ESP_Objetos) do
        if data.Name then
            data.Name.TextLabel.TextColor3 = ESP_Cor
        end
        if data.Tracer then
            data.Tracer.Color = ESP_Cor
        end
    end
end

-- Fun√ß√£o para remover ESP
function RemoverESP()
    for _, data in pairs(ESP_Objetos) do
        if data.Name then
            data.Name:Destroy()
        end
        if data.Tracer then
            data.Tracer:Remove()
        end
    end
    ESP_Objetos = {}
end

-- Atualizar ESP continuamente
RunService.RenderStepped:Connect(function()
    if ESP_Ativado then
        for jogador, data in pairs(ESP_Objetos) do
            if jogador and jogador.Character and jogador.Character:FindFirstChild("HumanoidRootPart") then
                local HRP = jogador.Character.HumanoidRootPart
                local Pos, OnScreen = workspace.CurrentCamera:WorldToViewportPoint(HRP.Position)

                if data.Name then
                    data.Name.Enabled = OnScreen
                end

                if data.Tracer then
                    data.Tracer.Visible = OnScreen
                    if OnScreen then
                        data.Tracer.From = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y)
                        data.Tracer.To = Vector2.new(Pos.X, Pos.Y)
                    end
                end
            end
        end
    end
end)
local Tab = Window:CreateTab("PLAYERS", 13289762774)

local Button = Tab:CreateButton({ Name = "Noclip üö™", Callback = function() 
    print("Noclip ativado!")
	local Noclip = nil
local Clip = nil

function noclip()
	Clip = false
	local function Nocl()
		if Clip == false and game.Players.LocalPlayer.Character ~= nil then
			for _,v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
				if v:IsA('BasePart') and v.CanCollide and v.Name ~= floatName then
					v.CanCollide = false
				end
			end
		end
		wait(0.21) -- basic optimization
	end
	Noclip = game:GetService('RunService').Stepped:Connect(Nocl)
end

function clip()
	if Noclip then Noclip:Disconnect() end
	Clip = true
end

noclip() -- to toggle noclip() and clip()
end })
local noFallEnabled = false

local Button = Tab:CreateButton({
    Name = "No Fall üíñ",
    Callback = function()
        noFallEnabled = not noFallEnabled -- Alterna entre ativado e desativado

        if noFallEnabled then
            print("‚úÖ No Fall Ativado!")

            local function deleteDamageEvents()
                for _, obj in ipairs(game:GetDescendants()) do
                    if obj:IsA("RemoteEvent") or obj:IsA("BindableEvent") then
                        if string.lower(obj.Name):find("damage") or string.lower(obj.Name):find("dano") then
                            obj:Destroy()
                        end
                    end
                end
            end

            deleteDamageEvents()

            game.DescendantAdded:Connect(function(obj)
                if noFallEnabled and (obj:IsA("RemoteEvent") or obj:IsA("BindableEvent")) then
                    if string.lower(obj.Name):find("damage") or string.lower(obj.Name):find("dano") then
                        obj:Destroy()
                    end
                end
            end)
        else
            print("‚ùå No Fall Desativado!")
        end
    end
})
game.DescendantAdded:Connect(function(obj)
    if obj:IsA("RemoteEvent") or obj:IsA("BindableEvent") then
        if string.lower(obj.Name):find("damage") or string.lower(obj.Name):find("dano") then
            obj:Destroy()
        end
    end
end)

local rev = Window:CreateTab("Auto-Roubar üè¥‚Äç‚ò†Ô∏è")
local Section = rev:CreateSection("NECESSARIO")
local Button = rev:CreateButton({
   Name = "puxa itens",
   Callback = function()
   -- Fun√ß√£o para deletar todas as NotifyGui
local function deletarNotifyGui()
    local playerGui = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    for _, gui in ipairs(playerGui:GetChildren()) do
        if gui.Name == "NotifyGui" and gui:IsA("ScreenGui") then
            gui:Destroy() -- Deleta a NotifyGui
        end
    end
end

-- Lista de itens para pegar
local itens = {"AK47", "Uzi", "Parafal", "Faca", "IA2", "G3", "IPhone 14", "Agua", "Hamburguer", "Hi Power", "Natalina", "tratamento", "Escudo", "Pe√ßa de Arma"}

-- Argumentos para a requisi√ß√£o
local args = {
    [1] = "mudaInv",
    [2] = "2",
    [4] = "1"
}

-- Loop principal
while true do
    -- Deletar todas as NotifyGui antes de pegar os itens
    deletarNotifyGui()

    -- Pegar itens
    for i, item in ipairs(itens) do
        if i <= 16 then  -- S√≥ tenta alocar at√© 16 slots
            args[3] = item  -- Atualiza o item para o valor da vez
            args[2] = tostring(i)  -- Atribui o slot dinamicamente (1, 2, 3, ..., 16)

            -- Usar task.spawn() para execu√ß√£o sem delay
            task.spawn(function()
                -- Envia a requisi√ß√£o para o servidor
                game:GetService("ReplicatedStorage"):WaitForChild("Modules"):WaitForChild("InvRemotes"):WaitForChild("InvRequest"):InvokeServer(unpack(args))
            end)
        end
    end

    wait(0)  -- Espera um frame para evitar lag
end
   end,
})
local Section = rev:CreateSection("PC")
local ww = rev:CreateToggle({
   Name = "mandar revistar (TECLA E)",
   CurrentValue = false,
   Flag = "rvst",
   Callback = function(Value)
       getgenv().Enabled = Value
   end,
})
local Section = rev:CreateSection("MOBILE")
local mob = rev:CreateButton({
   Name = "mandar revistar UI",
   Callback = function()
   local TextChatService = game:GetService("TextChatService")

-- Fun√ß√£o para enviar a mensagem /revistar morto
local function sendRevistarMessage()
    local channel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
    channel:SendAsync("/revistar morto")
end

-- Cria a interface
local ScreenGui = Instance.new("ScreenGui")
local Frame = Instance.new("Frame")
local CloseButton = Instance.new("TextButton")
local RevistarButton = Instance.new("TextButton")
local Title = Instance.new("TextLabel")

ScreenGui.Name = "Revistar mobaile"
ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

-- Estilo do Frame
Frame.Size = UDim2.new(0, 300, 0, 150)
Frame.Position = UDim2.new(0.5, -150, 0.5, -75)
Frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Frame.BorderSizePixel = 0
Frame.BackgroundTransparency = 0.1
Frame.Active = true
Frame.Draggable = true

-- T√≠tulo
Title.Size = UDim2.new(1, 0, 0, 30)
Title.Position = UDim2.new(0, 0, 0, 0)
Title.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
Title.Text = "Arthur"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.Font = Enum.Font.SourceSansBold
Title.TextSize = 18

-- Bot√£o Fechar
CloseButton.Size = UDim2.new(0, 30, 0, 30)
CloseButton.Position = UDim2.new(1, -30, 0, 0)
CloseButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
CloseButton.Text = "X"
CloseButton.TextColor3 = Color3.fromRGB(255, 255, 255)
CloseButton.Font = Enum.Font.SourceSansBold
CloseButton.TextSize = 18
CloseButton.MouseButton1Click:Connect(function()
    ScreenGui:Destroy()
end)


-- Bot√£o Revistar
RevistarButton.Size = UDim2.new(0.8, 0, 0.4, 0)
RevistarButton.Position = UDim2.new(0.1, 0, 0.5, -30)
RevistarButton.BackgroundColor3 = Color3.fromRGB(50, 150, 250)
RevistarButton.Text = "manda /revistar morto"
RevistarButton.TextColor3 = Color3.fromRGB(255, 255, 255)
RevistarButton.Font = Enum.Font.SourceSansBold
RevistarButton.TextSize = 20
RevistarButton.AutoButtonColor = true
RevistarButton.MouseButton1Click:Connect(function()
    sendRevistarMessage()
end)

-- Adiciona os elementos ao frame
Frame.Parent = ScreenGui
Title.Parent = Frame
CloseButton.Parent = Frame
RevistarButton.Parent = Frame
   end,
})
local otoTab = Window:CreateTab("anti staff üëæ")
local Toggle = otoTab:CreateToggle({
    Name = "anti staff V2",
    CurrentValue = false,
    Flag = "ToggleKickCheck",
    Callback = function(Value)
        if Value then
            getgenv().KickCheck = true
            local Players = game:GetService("Players")
            local LocalPlayer = Players.LocalPlayer
            
            -- Lista de jogadores proibidos
            local blacklist = {
                "jake56839ad", "CleitinDoGrau_Eb", "21peteca", "Lucalarte", "SPTmatheus123",
                "GuilhermeDRTgg", "Briessxz", "hardstyless", "Mundaka", "Isabelaaaaafofs",
                "HANRLLEY25", "kaleb_iaee", "brunizoraa", "rip_propleyfran", "pepezicador",
                "Jjhgul", "Dariosantos21048", "JEKER_2009", "tttonas", "MZPlug14k",
                "Dudubeterotv5", "Sargento_admOficial", "Cassiopia84un", "Hakplays", "Cleo_ptr"
            }

            -- Criar uma tabela para verifica√ß√£o r√°pida
            local targetLookup = {}
            for _, name in ipairs(blacklist) do
                targetLookup[name] = true
            end

            -- Fun√ß√£o para verificar e expulsar jogadores
            local function checkPlayer(player)
                if not player or not player:IsA("Player") then return end
                
                task.wait(1) -- Pequeno atraso para garantir que o jogador foi carregado completamente
                
                if targetLookup[player.Name] then
                    pcall(function()
                        player:Kick("Voc√™ foi expulso do jogo.")
                    end)
                    print("Expulsando jogador proibido: " .. player.Name)
                end
            end

            -- Conectar ao evento de entrada de jogadores
            Players.PlayerAdded:Connect(checkPlayer)

            -- Anti-Staff: Detecta jogadores com cargos espec√≠ficos (Exemplo: "Moderator", "Admin")
            local function antiStaff(player)
                if not player or not player:IsA("Player") then return end
                
                local success, result = pcall(function()
                    return player:GetRankInGroup(1234567) -- Substitua 1234567 pelo ID do grupo desejado
                end)
                
                if success and result >= 200 then -- Ajuste o rank m√≠nimo conforme necess√°rio
                    pcall(function()
                        player:Kick("Acesso negado para membros da staff.")
                    end)
                    print("Expulsando staff: " .. player.Name)
                end
            end

            Players.PlayerAdded:Connect(antiStaff)

            -- Fun√ß√£o para verificar e kickar caso necess√°rio
            local function checkForTargetPlayers()
                if not getgenv().KickCheck then return end

                for _, player in pairs(Players:GetPlayers()) do
                    if targetLookup[player.Name] then
                        warn("Usu√°rio indesejado detectado:", player.Name)
                        LocalPlayer:Kick("Um staff foi detectado no servidor.")
                        break
                    end
                end
            end

            -- Verifica inicialmente
            checkForTargetPlayers()

            -- Verifica sempre que um novo jogador entrar
            Players.PlayerAdded:Connect(function(player)
                if getgenv().KickCheck and targetLookup[player.Name] then
                    warn("Usu√°rio indesejado detectado:", player.Name)
                    LocalPlayer:Kick("Um staff foi detectado no servidor.")
                end
            end)
            
            print("Verifica√ß√£o ativada.")
        else
            getgenv().KickCheck = false
        end
    end
})

-- Loop para checar a cada 5 segundos, apenas se ativado
task.spawn(function()
    while true do
        if getgenv().KickCheck then
            checkForTargetPlayers()
        end
        task.wait(5)
    end
end)

local Section = otoTab:CreateSection("AUTO CL CONFIG")
-- Verifica se getgenv est√° dispon√≠vel
if getgenv == nil then
    error("getgenv n√£o est√° definido neste ambiente.")
end

-- Configura√ß√£o inicial do getgenv
getgenv().KickOnLowHealth = false -- Ativar/desativar o auto kick
getgenv().HealthThreshold = 10    -- Vida m√≠nima antes de ser expulso

-- Fun√ß√£o para monitorar a vida do jogador
local function monitorHealth()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if character and character:FindFirstChild("Humanoid") then
        local humanoid = character.Humanoid
        humanoid.HealthChanged:Connect(function(health)
            if health <= getgenv().HealthThreshold and getgenv().KickOnLowHealth then
                player:Kick("Auto cl pq tua vida tava abaixo de " .. getgenv().HealthThreshold)
            end
        end)
    end
end

game.Players.LocalPlayer.CharacterAdded:Connect(function()
    monitorHealth()
end)

if game.Players.LocalPlayer.Character then
    monitorHealth()
end

-- Cria√ß√£o do Toggle para ativar/desativar o auto kick
local Toggle = otoTab:CreateToggle({
   Name = "auto CL",
   CurrentValue = getgenv().KickOnLowHealth,
   Flag = "AutoKickToggle",
   Callback = function(Value)
       getgenv().KickOnLowHealth = Value
   end,
})

-- Cria√ß√£o do Slider para ajustar o limite de vida
local Slider = otoTab:CreateSlider({
   Name = "kick quando vida =",
   Range = {0, 100},
   Increment = 1,
   Suffix = " HP",
   CurrentValue = getgenv().HealthThreshold,
   Flag = "HealthThresholdSlider",
   Callback = function(Value)
       getgenv().HealthThreshold = Value
   end,
})

getgenv().Key = Enum.KeyCode.E
getgenv().Enabled = getgenv().Enabled or false
local UserInputService = game:GetService("UserInputService")

-- Configura√ß√µes via getgenv
getgenv().Key = getgenv().Key or Enum.KeyCode.R -- Tecla padr√£o: R
getgenv().Enabled = getgenv().Enabled or false -- Estado inicial: desativado

-- Fun√ß√£o para enviar a mensagem /revistar
local function sendRevistarMessage()
    local TextChatService = game:GetService("TextChatService")
    local channel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
    channel:SendAsync("/revistar morto")
end

-- Listener para detectar teclas pressionadas
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    -- Verifica se o script est√° ativado e se a tecla correta foi pressionada
    if getgenv().Enabled and input.KeyCode == getgenv().Key and not gameProcessed then
        sendRevistarMessage()
    end
end)
local Tab = Window:CreateTab("Carros", 12338080417)
local Button = Tab:CreateButton({
    Name = "Destrancar Carro üîë",
    Callback = function()
        print("By Arthur Menu")

        local Players = game:GetService("Players")
        local LocalPlayer = Players.LocalPlayer
        local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
        local HRP = Character:WaitForChild("HumanoidRootPart")

        local closestSeat = nil
        local closestDistance = math.huge

        for _, obj in ipairs(workspace:GetDescendants()) do
            if obj:IsA("VehicleSeat") and obj.Name == "DriveSeat" then
                local distance = (HRP.Position - obj.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestSeat = obj
                end
            end
        end

        if closestSeat then
            pcall(function()
                closestSeat.CanCollide = true
                closestSeat.CanTouch = true
                closestSeat.CanQuery = true

                if pcall(function() return closestSeat.Disabled ~= nil end) then
                    closestSeat.Disabled = false
                end
            end)
        end
    end
})

local Button = Tab:CreateButton({ Name = "Deletar Carros ‚ùå", Callback = function() 
    print("Todos os carros deletados!")
end })
local Button = Tab:CreateButton({ Name = "Mudar Cor Visual üî•", Callback = function() 
    print("Turbo infinito ativado!")
end })
local TeleportTab = Window:CreateTab("Teleports üï≥Ô∏è")
local function addTeleportButton(name, cframe)
    TeleportTab:CreateButton({
        Name = name,
        Callback = function()
            local player = game.Players.LocalPlayer
            if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
                player.Character:MoveTo(cframe.Position + Vector3.new(0, 3, 0))
            end
        end,
    })
end
-- Adicionando os bot√µes de teletransporte para locais fixos
addTeleportButton("Teleport Pra√ßa", CFrame.new(-291.579559, 3.26299787, 342.192535))
addTeleportButton("Teleport G√°s", CFrame.new(-469.959015, 3.25349784, -54.3936005))
addTeleportButton("Teleport HP", CFrame.new(-543.439941, 3.26299858, 645.16864))
addTeleportButton("Teleport Tabacaria", CFrame.new(-83.1141129, 13.1430578, 74.7073364))
addTeleportButton("Teleport Garagem", CFrame.new(-466.870148, 7.64567232, 350.242737))
addTeleportButton("Teleport Concessionaria", CFrame.new(-91.3902893, 8.07136822, 520.355347))
addTeleportButton("Teleport Gari", CFrame.new(-518.672852, 3.16749811, -1.16962147, 0, 0, -1, 0, 1, 0, 1, 0, 0))
addTeleportButton("Teleport Imobiliaria", CFrame.new(-284.904785, 8.26088619, -72.2896194, 0, 0, -1, 0, 1, 0, 1, 0, 0))
addTeleportButton("Teleport PM", CFrame.new(-980.181458, 2.27553082, 467.080536, 1, 0, 0, 0, 1, 0, 0, 0, 1))
addTeleportButton("Teleport PRF", CFrame.new(6662.24512, 36.6637421, 5047.83838, 0.707134247, 0, 0.707079291, 0, 1, 0, -0.707079291, 0, 0.707134247))
addTeleportButton("Teleport Minera√ß√£o", CFrame.new(201.932144, 2.76136589, 145.50531, 0, 0, 1, 0, 1, -0, -1, 0, 0))
addTeleportButton("Teleport Mec√¢nica", CFrame.new(-180.608261, 3.29813337, -532.4151, 0.422592998, -0, -0.906319618, 0, 1, -0, 0.906319618, 0, 0.422592998))
addTeleportButton("Teleport Fazenda", CFrame.new(817.243225, 3.26249814, -87.316864, 0, 0, 1, 0, 1, 0, -1, 0, 0))
addTeleportButton("Teleport Prefeitura", CFrame.new(-284.388458, 15.1148872, 88.0397873, 0, 0, -1, 0, 1, 0, 1, 0, 0))
addTeleportButton("Teleport Banco", CFrame.new(-27.2709007, 11.5685892, 418.200653, 1, 0, 0, 0, 1, 0, 0, 0, 1))
addTeleportButton("Teleport Ilegal", CFrame.new(12037.2705, 27.5305443, 12794.0635, 0.965929627, -0, -0.258804798, 0, 1, -0, 0.258804798, 0, 0.965929627))
addTeleportButton("Teleport predio 1", CFrame.new(-1595.23328, 204.074341, 555.895386, 0.939687431, -0.34203434, 1.81794167e-06, 1.81794167e-06, 1.02519989e-05, 1, -0.34203434, -0.93968749, 1.02519989e-05))
addTeleportButton("Teleport Devs Mini City", CFrame.new(2555.44263, 303.167755, -1004.13763, -0.422592998, 0, 0.906319618, 0, 1, 0, -0.906319618, 0, -0.422592998))
local Tab = Window:CreateTab("CONFIGS", 17124529105)
local Button = Tab:CreateButton({ Name = "Fps AntiLag üöÄ", Callback = function() 
    print("Modo AntiLag ativado!")
end })
local Button = Tab:CreateButton({ Name = "Resetar Configura√ß√µes üîÑ", Callback = function() 
    print("Configura√ß√µes resetadas!")
end })


